# 1c-task

Чтобы получить "ориентированный" ответ, нужно передать параметр "oriented" в аргументах командной строки. В программе поддерживаются следующие ориентиры:
"северо-запад", "север", "северо-восток",
"запад", "центр", "восток",
"юго-запад", "юг", "юго-восток".


Программа предполагает, что пользователь разумно указывает матрицы: нет гарантий корректной работы программы, в случае, когда в матрице длина одной строки меньше остальных, или какая-то из матриц не была передана. Предполагается, что обе матрицы не пустые. Также, исходя из условия поставленной задачи предполагается, что вторая матрица всегда найдется.
Также, между первой и второй матрицей обязательно должен быть непробельный разделитель, например:

1 2 3

4 5 6

7 8 9

Submatrix:

5 6

8 9



Решение задачи основано на алгоритме Кнута-Морриса-Прата.
Идея: Превратить исходное изображение-двумерный массив в одномерный массив чисел. То изображение, которое мы ищем, рассматриваем как множество "паттернов" - строк. Будем считать, что мы нарезали искомое изображение на горизонтальные ленты. Тогда выполняя алгоритм по очереди для каждой ленты, получим все ее вхождения в исходный массив. Мы должны учитывать, что лента должна не просто присутствовать двумерном массиве, но и помещаться в его "истинную", изначальную длину строки. После того, как для каждой ленты мы нашли все вхождения, осталось перебрать для каждого вхождения "первой" ленты подходящие вхождения остальных лент по принципу: все ленты должны иметь такой же сдвиг от начала строки, как и первая, но каждая должна находиться на одну строку ниже предыдущей. Для эффективного перебора используются хеши.

Сложность алгоритма:
Пусть X, Y - размеры первого изображения,  M, N - размеры второго изображения. Тогда выполнение алгоритма КМП для одной ленты займет O(X*Y + N), а для всех лент  O(M*(X*Y + N)). Сложность перебора подходящих позиций зависит от количества подходящих позиций для первой ленты ("проверка, что остальные ленты подходят, занимает O(1), Т.К. используем хеши.") и количества лент, т. е. в худшем случае для каждой позиции первой ленты проверяем все остальные ленты: O(X*Y*M). Итого общая сложность O(2M*(X*Y + N)).

Для ускорения работы алгоритма с "ориентированным ответом" пришлось пожертвовать точностью проверки. При переданной опции "oriented" для получения "ориентира" программа проверяет соответствие не каждой ленты, а каждой второй ленты. 

